# retrieval/bm25_client.py
from __future__ import annotations
from typing import List, Dict, Iterable, Tuple
from pathlib import Path
import json
from rank_bm25 import BM25Okapi
import re

def _simple_tokenize(text: str) -> List[str]:
    # Simple robust tokenizer (lowercase + \w)
    return re.findall(r"\w+", text.lower(), flags=re.UNICODE)

class BM25Client:
    """
    BM25 client that consumes the KB JSONL generated by:
      ingestion/ingest.py -> build_kb(..., kb_out="data/kb/bm25.jsonl")

    Expected JSON format per line:
      {"text": str, "tokens": List[str], "source": str, "meta": dict}
    """
    def __init__(self, kb_path: str | Path = "data/kb/bm25.jsonl") -> None:
        self.kb_path = Path(kb_path)
        if not self.kb_path.exists():
            raise FileNotFoundError(f"KB not found: {self.kb_path}")

        self._docs: List[str] = []
        self._sources: List[str] = []
        self._metas: List[Dict] = []
        self._tokens: List[List[str]] = []

        with self.kb_path.open("r", encoding="utf-8") as f:
            for line in f:
                if not line.strip():
                    continue
                obj = json.loads(line)
                text = obj.get("text", "")
                tokens = obj.get("tokens") or _simple_tokenize(text)
                source = obj.get("source", "?")
                meta = obj.get("meta", {})

                self._docs.append(text)
                self._tokens.append(tokens)
                self._sources.append(source)
                self._metas.append(meta)

        if not self._docs:
            raise ValueError(f"KB is empty: {self.kb_path}")

        self._bm25 = BM25Okapi(self._tokens)

    def search(self, query: str, k: int = 5) -> List[Dict]:
        """
        Returns a list of dictionaries:
          {"text", "score", "source", "meta"}
        """
        q_tokens = _simple_tokenize(query)
        if not q_tokens:
            idx = list(range(min(k, len(self._docs))))
            return [self._make_hit(i, score=0.0) for i in idx]

        scores = self._bm25.get_scores(q_tokens)
        idx = sorted(range(len(scores)), key=lambda i: scores[i], reverse=True)[:k]
        return [self._make_hit(i, float(scores[i])) for i in idx]

    def search_with_scores(self, query: str, k: int = 5) -> List[Tuple[str, float, str]]:
        """
        Returns a list of tuples (text, score, source) â€” useful for debugging.
        """
        hits = self.search(query, k=k)
        return [(h["text"], h["score"], h["source"]) for h in hits]

    def _make_hit(self, i: int, score: float) -> Dict:
        return {
            "text": self._docs[i],
            "score": score,
            "source": self._sources[i],
            "meta": self._metas[i],
        }
